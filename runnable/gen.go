package runnable

import (
	"errors"
	"fmt"
	"log"
	"strings"

	"github.com/jcorbin/intsearch/word"
)

var (
	errAlreadyUsed = errors.New("value already used")
	errCheckFailed = errors.New("check failed")
	errNoChoices   = errors.New("no choices left")
)

// StepGen implements a word.SolutionGen that builds a program listing of Steps
// that will progress the solution state.
type StepGen struct {
	*word.PlanProblem
	steps       []Step
	carryPrior  *word.Column
	carrySaved  bool
	carryValid  bool
	usedSymbols map[string]struct{}
	labels      map[string]int
	addrAnnos   map[int][]string
}

// NewStepGen creates a new step generator for a given problem about to be planned.
func NewStepGen(prob *word.PlanProblem) word.SolutionGen {
	n := 0
	for _, w := range prob.Words {
		n += len(w)
	}
	gg := &StepGen{
		PlanProblem: prob,
		usedSymbols: make(map[string]struct{}, 3*len(prob.Letters)),
		steps:       make([]Step, 0, n*50),
	}
	if prob.Annotated {
		gg.addrAnnos = make(map[int][]string)
	}
	return gg
}

// Problem returns the plan problem.
func (gg *StepGen) Problem() *word.PlanProblem {
	return gg.PlanProblem
}

// Steps returns the slice of steps generated/compiled so far.
func (gg *StepGen) Steps() []Step {
	return gg.steps
}

func (gg *StepGen) copy() *StepGen {
	alt := &StepGen{
		PlanProblem: gg.PlanProblem,
		usedSymbols: gg.usedSymbols,
		steps:       make([]Step, 0, cap(gg.steps)),
	}
	// TODO: carry state copy... but whither column
	return alt
}

// LabelAt returns any annotations for the given address, joined by a ", ".
func (gg *StepGen) LabelAt(i int) string {
	if i > len(gg.steps) {
		return "INVALID"
	}
	if gg.addrAnnos == nil {
		return ""
	}
	if annos := gg.addrAnnos[i]; len(annos) > 0 {
		return strings.Join(annos, ", ")
	}
	return ""
}

// LabelFor returns any annotations for the given solution's current step,
// joined by a ", ".
func (gg *StepGen) LabelFor(sol *Solution) string {
	return gg.LabelAt(sol.stepi)
}

// Logf does nothing.
func (gg *StepGen) Logf(format string, args ...interface{}) error {
	return nil
}

// Init does nothing.
func (gg *StepGen) Init(desc string) {
}

// Fork creates a copy of the StepGen, and adds a step which will fork to the
// step list generated by the copy.
//
// In other words:
//     var orig StepGen
//     copy := orig.Fork(prob, "name", "alt", "cont")
//     // copy now generates steps for the alternate path
//     // while orig generates steps for the continuation path
func (gg *StepGen) Fork(prob *word.PlanProblem, name, altLabel, contLabel string) word.SolutionGen {
	if altLabel != "" {
		altLabel = gg.gensym("%s:alt", altLabel)
	}
	if contLabel != "" {
		contLabel = gg.gensym("%s:cont", contLabel)
	}
	alt := gg.copy()
	alt.PlanProblem = prob
	gg.steps = append(gg.steps, forkAltStep{
		alt:       alt,
		name:      name,
		altLabel:  altLabel,
		contLabel: contLabel,
	})
	return alt
}

// Fix adds steps to fix the value of c to v.
func (gg *StepGen) Fix(c byte, v int) {
	if gg.addrAnnos != nil {
		gg.steps = append(gg.steps,
			labelStep(gg.gensym("fix(%s)", string(c))))
	}
	gg.steps = append(gg.steps,
		setAStep(v),
		storeAStep(c))
}

func (gg *StepGen) stashCarry(col *word.Column) {
	if gg.carryPrior == col && (col == nil || gg.carrySaved) {
		return
	}

	if col == nil {
		gg.carrySaved = false
		gg.carryPrior = nil
		return
	}

	if !gg.carryValid {
		return
	}

	if gg.addrAnnos != nil {
		gg.steps = append(gg.steps,
			labelStep(gg.gensym("stashCarry(%d)", col.I)))
	}
	gg.steps = append(gg.steps, setCAStep{})
	gg.carrySaved = true
	gg.carryPrior = col
}

func (gg *StepGen) saveCarry(col *word.Column) {
	if !gg.carryValid {
		gg.ensureCarry(col)
	}
	gg.stashCarry(col)
}

// ComputeSum adds steps to compute the sum character from its summands.
//
// That is, given a column:
//     carry + a + b = c (mod base)
// Compute c:
//     c = carry + a + b (mod base)
func (gg *StepGen) ComputeSum(col *word.Column) {
	a, b, c := col.Chars[0], col.Chars[1], col.Chars[2]
	gg.ensureCarry(col.Prior)
	gg.carryValid = false
	gg.carrySaved = false

	steps := make([]Step, 0, 12)
	if gg.addrAnnos != nil {
		steps = append(steps,
			labelStep(gg.gensym("computeSum(%s)", col.Label())))
	}
	if a != 0 {
		steps = append(steps, addAValueStep(a))
	}
	if b != 0 {
		steps = append(steps, addAValueStep(b))
	}
	steps = append(steps,
		setCAStep{},
		modAStep(gg.Base),
		setBAStep{},
		usedAStep{},
		relJZStep(1),
		exitStep{errCheckFailed},
		storeBStep(c),
		setACStep{},
		divAStep(gg.Base))
	gg.steps = append(gg.steps, steps...)

	gg.carryPrior = col
	gg.carryValid = true
	gg.carrySaved = false

	gg.checkAfterCompute(col, c)
}

// ComputeFirstSummand adds steps to compute the first summand from its sum and
// the other summand.
//
// That is, given a column:
//     carry + a + b = c (mod base)
// Compute a:
//     a = c - b - carry (mod base)
func (gg *StepGen) ComputeFirstSummand(col *word.Column) {
	gg.computeSummand(col, col.Chars[0], col.Chars[1], col.Chars[2])
}

// ComputeSecondSummand adds steps to compute the second summand from its sum
// and the other summand.
//
// That is, given a column:
//     carry + a + b = c (mod base)
// Compute b:
//     b = c - a - carry (mod base)
func (gg *StepGen) ComputeSecondSummand(col *word.Column) {
	gg.computeSummand(col, col.Chars[1], col.Chars[0], col.Chars[2])
}

func (gg *StepGen) computeSummand(col *word.Column, a, b, c byte) {
	gg.ensureCarry(col.Prior)
	if !gg.carrySaved {
		gg.steps = append(gg.steps, setCAStep{})
	}

	gg.carryValid = false
	gg.carrySaved = false

	steps := make([]Step, 0, 10)
	if gg.addrAnnos != nil {
		steps = append(steps,
			labelStep(gg.gensym("computeSummand(%s)", col.Label())))
	}
	steps = append(steps, negAStep{})
	if c != 0 {
		steps = append(steps, addAValueStep(c))
	}
	if b != 0 {
		steps = append(steps, subAValueStep(b))
	}
	steps = append(steps,
		modAStep(gg.Base),
		setBAStep{},
		usedBStep{},
		relJZStep(1),
		exitStep{errCheckFailed},
		storeBStep(a))
	gg.steps = append(gg.steps, steps...)

	gg.carryPrior = col
	gg.carryValid = false
	gg.carrySaved = false

	if b != 0 {
		gg.steps = append(gg.steps,
			setACStep{},
			addARegBStep{},
			addAValueStep(b),
			divAStep(gg.Base),
		)
		gg.carryValid = true
	} else {
		gg.steps = append(gg.steps,
			setACStep{},
			addARegBStep{},
			divAStep(gg.Base),
		)
		gg.carryValid = true
	}

	gg.checkAfterCompute(col, a)
}

func (gg *StepGen) checkAfterCompute(col *word.Column, c byte) {
	if c == gg.Words[0][0] || c == gg.Words[1][0] || c == gg.Words[2][0] {
		gg.checkInitialLetter(col, c)
	}
	gg.checkFixedCarry(col)
}

func (gg *StepGen) checkInitialLetter(col *word.Column, c byte) {
	if gg.carryValid {
		gg.stashCarry(col)
		gg.carryValid = false
	}
	if gg.addrAnnos != nil {
		gg.steps = append(gg.steps,
			labelStep(gg.gensym("checkInitialLetter(%s)", string(c))))
	}
	gg.steps = append(gg.steps,
		loadAStep(c),
		relJNZStep(1),
		exitStep{errCheckFailed})
}

func (gg *StepGen) checkFixedCarry(col *word.Column) {
	switch col.Carry {
	case word.CarryZero:
		fallthrough
	case word.CarryOne:
		if !gg.restoreCarry(col) {
			return
		}
	default:
		return
	}

	switch col.Carry {
	case word.CarryZero:
		if gg.addrAnnos != nil {
			gg.steps = append(gg.steps,
				labelStep(gg.gensym("checkFixedCarry(%s)", col.Label())))
		}
		gg.steps = append(gg.steps,
			relJZStep(1),
			exitStep{errCheckFailed})
	case word.CarryOne:
		if gg.addrAnnos != nil {
			gg.steps = append(gg.steps,
				labelStep(gg.gensym("checkFixedCarry(%s)", col.Label())))
		}
		gg.steps = append(gg.steps,
			relJNZStep(1),
			exitStep{errCheckFailed})
	}
}

// ChooseRange adds steps to try all remaining unchosen digits in a range for
// the character c.
func (gg *StepGen) ChooseRange(c byte, min, max int) {
	gg.stashCarry(gg.carryPrior)
	gg.carryValid = false
	label := ""
	if gg.addrAnnos != nil {
		label = gg.gensym("choose(%s)", string(c))
	}
	gg.steps = append(gg.steps,
		rangeStep{label, min, max}, // range [$min, $max]
		storeBStep(c),              // store $c, rb
	)
}

func (gg *StepGen) restoreCarry(col *word.Column) bool {
	if col != gg.carryPrior {
		return false
	}
	if gg.carryValid {
		return true
	}
	if !gg.carrySaved {
		return false
	}
	if gg.addrAnnos != nil {
		gg.steps = append(gg.steps,
			labelStep(gg.gensym("restoreCarry(%d)", col.I)))
	}
	gg.steps = append(gg.steps, setACStep{})
	gg.carryValid = true
	return true
}

func (gg *StepGen) ensureCarry(col *word.Column) {
	if col == nil {
		if gg.addrAnnos != nil {
			gg.steps = append(gg.steps,
				labelStep(gg.gensym("ensureCarry:nil")))
		}
		gg.steps = append(gg.steps, setAStep(0))
		gg.carryPrior = nil
		gg.carrySaved = false
		gg.carryValid = true
		return
	}

	switch col.Carry {
	case word.CarryZero:
		fallthrough
	case word.CarryOne:
		if gg.addrAnnos != nil {
			gg.steps = append(gg.steps,
				labelStep(gg.gensym("ensureCarry(%d):fixed", col.I)))
		}
		gg.steps = append(gg.steps, setAStep(col.Carry))
		gg.carryPrior = col
		gg.carrySaved = false
		gg.carryValid = true
		return
	}

	if gg.restoreCarry(col) {
		return
	}

	c1 := col.Chars[0]
	if c1 != 0 && !gg.Known[c1] {
		log.Fatalf("cannot compute carry from unknown c1 for column %v", col)
	}

	c2 := col.Chars[1]
	if c2 != 0 && !gg.Known[c2] {
		log.Fatalf("cannot compute carry from unknown c2 for column %v", col)
	}

	gg.ensureCarry(col.Prior)
	if gg.addrAnnos != nil {
		gg.steps = append(gg.steps,
			labelStep(gg.gensym("computeCarry(%s)", col.Label())))
	}
	steps := make([]Step, 0, 3)
	if c1 != 0 {
		steps = append(steps, addAValueStep(c1))
	}
	if c2 != 0 {
		steps = append(steps, addAValueStep(c2))
	}
	steps = append(steps, divAStep(gg.Base))
	gg.steps = append(gg.steps, steps...)

	gg.carryPrior = col
	gg.carrySaved = false
	gg.carryValid = true
}

// Check adds steps that check if the selected mapping of letters to digits
// works.  Check's work failing is a normal terminal solution (e.g. used by
// brute force search).
func (gg *StepGen) Check(err error) {
	if gg.addrAnnos == nil {
		gg.doVerify("", err)
	} else {
		gg.doVerify("check", err)
	}
}

// CheckColumn solves a column by checking that it clears; this is useful when
// all the characters in a column have already been determined by other
// columns.
func (gg *StepGen) CheckColumn(col *word.Column, err error) {
	if err == nil {
		err = errCheckFailed
	}

	a, b, c := col.Chars[0], col.Chars[1], col.Chars[2]
	gg.ensureCarry(col.Prior)
	if gg.addrAnnos != nil {
		gg.steps = append(gg.steps,
			labelStep(gg.gensym("checkColumn(%s)", col.Label())))
	}
	steps := make([]Step, 0, 9)

	n := 0
	if a != 0 {
		n++
		steps = append(steps, addAValueStep(a))
	}
	if b != 0 {
		n++
		steps = append(steps, addAValueStep(b))
	}
	if n > 0 {
		steps = append(steps,
			setCAStep{},
			modAStep(gg.Base))
	}
	steps = append(steps,
		subAValueStep(c),
		relJZStep(1),
		exitStep{err})
	if n > 0 {
		steps = append(steps,
			setACStep{},
			divAStep(gg.Base))
	} else {
		steps = append(steps, setAStep(0))
	}
	gg.carryPrior = col
	gg.carrySaved = false
	gg.carryValid = true
	gg.steps = append(gg.steps, steps...)
}

// Verify adds steps that verify that the selected mapping of letters to digits
// works.  Verify's work failing is an error terminal solution (e.g. used to
// test correctness of the planned program).
func (gg *StepGen) Verify() {
	if gg.addrAnnos == nil {
		gg.doVerify("", nil)
	} else {
		gg.doVerify("verify", nil)
	}
}

func (gg *StepGen) doVerify(name string, err error) {
	if name != "" {
		name = gg.gensym(name)
	}
	gg.steps = append(gg.steps, labelStep(name))
	gg.verifyInitialLetters(name, err)
	gg.verifyDuplicateLetters(name, err)
	gg.verifyLettersNonNegative(name, err)
	gg.verifyColumns(name, err)
}

func (gg *StepGen) verifyColumns(name string, err error) {
	// verify columns from bottom up
	for i := len(gg.Columns) - 1; i >= 0; i-- {
		if gg.Columns[i].Unknown > 0 {
			return
		}
		col := &gg.Columns[i]
		colErr := err
		if colErr == nil {
			colErr = word.VerifyError(col.Label())
		}
		gg.CheckColumn(col, colErr)
	}

	// final carry may be constant by construction
	if step, ok := gg.steps[len(gg.steps)-1].(setAStep); ok {
		if int(step) != 0 {
			panic("broken final carry")
		}
		return
	}

	// final carry must be 0
	finErr := err
	if finErr == nil {
		finErr = word.VerifyError("final carry must be 0")
	}
	gg.steps = append(gg.steps,
		relJZStep(1),
		exitStep{finErr})
}

func (gg *StepGen) verifyInitialLetters(name string, err error) {
	if err == nil {
		err = word.VerifyError("initial letter cannot be zero")
	}
	if name != "" {
		gg.steps = append(gg.steps, labelStep(gg.gensym("%s:initialLetters", name)))
	}
	for _, word := range gg.Words {
		gg.steps = append(gg.steps,
			loadAStep(word[0]),
			relJNZStep(1),
			exitStep{err})
	}
}

func (gg *StepGen) verifyDuplicateLetters(name string, err error) {
	if err == nil {
		err = word.VerifyError("duplicate valued character")
	}
	if name != "" {
		gg.steps = append(gg.steps, labelStep(gg.gensym("%s:duplicateLetters", name)))
	}
	letters := gg.SortedLetters()
	for i, c := range letters {
		if !gg.Known[c] {
			continue
		}
		for j, d := range letters {
			if !gg.Known[d] {
				continue
			}
			if j > i {
				gg.steps = append(gg.steps,
					loadAStep(c),
					subAValueStep(d),
					relJNZStep(1),
					exitStep{err})
			}
		}
	}
}

func (gg *StepGen) verifyLettersNonNegative(name string, err error) {
	if err == nil {
		err = word.VerifyError("negative valued character")
	}
	if name != "" {
		gg.steps = append(gg.steps, labelStep(gg.gensym("%s:allLettersNonNegative", name)))
	}
	for _, c := range gg.SortedLetters() {
		if !gg.Known[c] {
			continue
		}
		gg.steps = append(gg.steps,
			loadAStep(c),
			ltAStep(0),
			relJZStep(1),
			exitStep{err})
	}
}

// Finish adds the final successful exit step.
func (gg *StepGen) Finish() {
	lastStep := gg.steps[len(gg.steps)-1]
	if _, isFinish := lastStep.(finishStep); isFinish {
		panic("double StepGen.finish")
	}
	gg.steps = append(gg.steps, finishStep(gg.gensym("finish")))
}

// Finalize compiles the generated steps (performs expansion and label
// resolution).
func (gg *StepGen) Finalize() word.Plan {
	gg.compile()
	return &SearchPlan{
		Problem:   &gg.PlanProblem.Problem,
		steps:     gg.steps,
		addrAnnos: gg.addrAnnos,
	}
}

func (gg *StepGen) takeAnnotation(addr int, annos ...string) {
	gg.addrAnnos[addr] = append(gg.addrAnnos[addr], annos...)
}

func (gg *StepGen) compile() {
	var parts [][]Step
	var addr int
	var annotate annoFunc
	if gg.addrAnnos != nil {
		annotate = gg.takeAnnotation
	}
	addr, parts, gg.labels = expandSteps(addr, gg.steps, nil, gg.labels, annotate)
	steps := make([]Step, 0, addr)
	for _, part := range parts {
		steps = append(steps, part...)
	}
	if len(steps) != addr {
		panic(fmt.Sprintf(
			"compiled final addr %d mismatches final step length %d by %d",
			addr, len(steps), addr-len(steps)))
	}
	gg.steps, gg.labels = resolveLabels(steps, gg.labels)
}

func (gg *StepGen) gensym(format string, args ...interface{}) string {
	name := fmt.Sprintf(format, args...)

	if _, used := gg.usedSymbols[name]; !used {
		gg.usedSymbols[name] = struct{}{}
		return name
	}

	i := 2
	for {
		sym := fmt.Sprintf("%s_%d", name, i)
		if _, used := gg.usedSymbols[sym]; !used {
			gg.usedSymbols[sym] = struct{}{}
			return sym
		}
		i++
	}
}

func printLastKSteps(k int, steps []Step) {
	i := len(steps) - k - 1
	if i < 0 {
		i = 0
	}
	for j, step := range steps[i:] {
		fmt.Printf("[%v]: %v\n", i+j, step)
	}
}
